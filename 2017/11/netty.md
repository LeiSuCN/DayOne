

#### [数据的发送流程](http://blog.csdn.net/chenxiang0207/article/details/14054545)
1. 应用程序首先将要发送的数据写入该进程的内存地址空间中。通常在程序开发中这只需要一般的运行时变量赋值即可。
2. 应用程序通过系统函数库接口（比如send函数）向内核发出系统调用，系统内核随后将这些数据从用户态内存复制到由内核维护的一段称为内核缓冲区的内存地址空间。这块地址空间的大小通常是有限的，所有要发送的数据将以队列的形式进入这里，这些数据可能来自多个进程，每块数据都有一定的额外记号来标记他的去向。
3. 当数据写入内核缓冲区后，内核会通知网卡控制器前来取数据，同时CPU转而处理其他进程。网卡控制器接到通知后，便根据网卡驱动信息得知对应内核缓冲区的地址，将要发送的数据复制到网卡的缓冲区。
4. 网卡缓冲区的数据需要发送到线路中，同时释放缓冲区来获得更多要发送的数据。但是只有二进制的数字信号才可以在线路中传输，所以这时候需要对数据进行字节到位的转换，然后将数据的每个位按照顺序依次发出。
5. 发送时网卡会使用内部特定的物理装置来生成可以传播的各种信号。比如在使用铜线线路时，网卡会根据“0”与“1”的变化产生不同的电信号；而使用光纤线路时，网卡会产生不同的光信号。

### [DirectBuffer的优势](https://www.zhihu.com/question/60892134)
1. 底层通过write、read、pwrite，pread函数进行系统调用时，需要传入buffer的起始地址和buffer count作为参数。如果使用java heap的话，我们知道jvm中buffer往往以byte[] 的形式存在，这是一个特殊的对象，由于java heap GC的存在，这里对象在堆中的位置往往会发生移动，移动后我们传入系统函数的地址参数就不是真正的buffer地址了，这样的话无论读写都会发生出错。而C Heap仅仅受Full GC的影响，相对来说地址稳定
2. JVM规范中没有要求Java的byte[]必须是连续的内存空间，它往往受宿主语言的类型约束；而C Heap中我们分配的虚拟地址空间是可以连续的，而上述的系统调用要求我们使用连续的地址空间作为buffer。